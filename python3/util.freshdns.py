#!/usr/bin/python3
'''
NAME

  freshdns - Boost DNS lookup speed by writing records into hosts

SYNOPSYS

  freshdns --help

DESCRIPTION

  NOTE: Run this script as root. Python >= 3.6 is required.

  This script can be used to (1) configure your resolv.conf via terminal
  version of dialog; (2) maintain a static lookup table in /etc/hosts.

  DNS cache of BIND and DNSMASQ could be polluted by attackers. However,
  the attackers cannot change your static lookup table. If a safe DNS
  server is not always accessible, this script could be a nice workaround
  for you to obtain clean lookup results.

  (1) Confiugre resolv.conf

      $ sudo freshdns -n

      The list of dns server candidates is stored in the _HOSTS_ string.
      They are identified by the '-dns' and the '-dns6' substrings.

  (2) Maintain the static lookup table

      This functionality features a fancy terminal output. If you choose
      to dryrun instead of automatically write results into /etc/hosts,
      you can also directly copy the screen output into /etc/hosts manually.

      The -j option specifies the number of workers for dns lookup. Default
      is 0. However with several workers you generally get a significant
      speed up.

      Reset the hosts file. The default content of hosts is exactly _HOSTS_.

        $ sudo freshdns -i

      Refresh the hosts file in serial mode.

        $ sudo freshdns -r

      If you would like to check the result and update hosts by yourself

        $ freshdns -v > output
        $ sudo mv output /etc/hosts

      Grab my firefox histroy and cache all of them with 10 workers

        $ freshdns -fv -j10 > output

FILES

  ~/.freshdnsrc
    A plain text file storing a list of your favorite domains. One domain
    per line.

VERSION

  4.1 (April 1 2018)

SEEALSO

  bind(?), dnsmasq(?), dig(?), nslookup(?)

COPYRIGHT

  Copyright (C) 2018 Mo Zhou <cdluminate@gmail.com>
  MIT LICENSE

TODO

  1. how to dump chromium history?
'''

import os
import re
import sys
import time
import socket
import sqlite3
import argparse
import multiprocessing as mp
from glob import glob
from typing import *
from dialog import Dialog


# Apologize. No support for python3 < 3.6
assert(sys.version_info[0] == 3)
assert(sys.version_info[1] >= 6)


_HOSTS_ = f'''# Automatically generated by {__file__} at {time.asctime()}
127.0.0.1 localhost {socket.gethostname()}

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters

# [ IPv4 DNS Servers ]
1.0.0.1                                                        cloudflare-dns-2
1.1.1.1                                                        cloudflare-dns-1
8.8.4.4                                                            google-dns-2
8.8.8.8                                                            google-dns-1
9.9.9.9                                                             quad9-dns-1
74.82.42.42                                                            he-dns-1
208.67.222.222                                                    opendns-dns-1
208.67.220.220                                                    opendns-dns-2
202.38.64.1                                                          ustc-dns-1
202.112.20.131                                                       ustc-dns-2
202.141.160.95                                                       ustc-dns-3
202.141.176.95                                                       ustc-dns-4
114.114.114.114                                                       114-dns-1


# [ IPv6 DNS Servers ]
2001:4860:4860::8888                                              google-dns6-1
2001:4860:4860::8844                                              google-dns6-2
2620:0:ccc::2                                                    opendns-dns6-1
'''

class Spinner(object):
    '''
    spinner
    '''
    def __init__(self):
        self.chars = '|/-\\'
        self.iter = 0
    def get(self):
        self.iter += 1
        return self.chars[self.iter % len(self.chars)]


def setResolvConf() -> None:
    '''
    Note, <resolv.h> :: MAXNS is 3
    '''
    global _HOSTS_

    NS_ALL = [line.strip().split() for line in _HOSTS_.split('\n')
              if not line.startswith('#') and '-dns' in line]
    #NS_v4 = [t for t in NS_ALL if '-dns-' in t[1]]
    #NS_v6 = [t for t in NS_ALL if '-dns6-' in t[1]]
    ns_choices = [(t[0], t[1], False) for t in NS_ALL]

    d = Dialog(dialog='dialog')
    d.set_background_title('Setting Up Name Servers')

    # select name servers
    code, tags = 'ok', []
    while code == 'ok' and not tags:
        code, tags = d.checklist("Select your favorite DNS servers.",
                                 height=0, width=0, list_height=0,
                                 choices=ns_choices,
                                 title='resolv.conf',
                                 backtitle='Setting Up Name Servers',
                                 )
        if code == 'cancel':
            exit(0)
        if not tags:
            d.msgbox("Note, at least one name server should be specified.")

    # write resolv.conf
    resolv = [f'# Auto-generated by {__file__} at {time.ctime()}\n']
    for tag in tags:
        resolv.append(f'nameserver {tag.rjust(64-11)}\n')
    try:
        with open(ag.resolv, 'w') as f:
            f.writelines(resolv)
    except PermissionError as e:
        print('Error: Are you root? resolv.conf unchanged.')
        exit(1)
    print('<> Updated resolv.conf')


def getFirefoxPlaces() -> List[str]:
    '''
    Retrieve a list of places from your firefox histroy (stored in sqlite3).
    '''
    dbpaths = glob(os.path.expanduser('~/.mozilla/firefox/**/places.sqlite'))
    ffplaces = []
    for dbpath in dbpaths:
        # read data from sqlite3
        conn = sqlite3.connect(dbpath)
        cursor = conn.cursor()
        cursor.execute('select url from moz_places;')
        places = cursor.fetchall()
        conn.close()
        # filter results
        places = [x[0].split('/') for x in places]
        places = [x[2] for x in places if len(x) > 2]  # get hostname
        places = [x.split(':')[0] for x in places if len(x) > 0]  # remove port
        places = [x for x in places if not
                  re.match('([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9])', x)]
        # don't lookup an IP address
        ffplaces += places
    return list(set(ffplaces))


def getChromiumPlaces() -> List[str]:
    raise NotImplementedError


def getAddrs(domain: str):
    '''
    This implementation is somewhat questionable. Anyway it works.
    '''
    #print(socket.getaddrinfo(domain, 80))
    addrinfo = []
    try:
        addrinfo = socket.getaddrinfo(domain, 80)
    except socket.gaierror as e:
        pass
    if len(addrinfo) == 0:
        try:
            addrinfo = socket.getaddrinfo(domain, 443)
        except socket.gaierror as e:
            pass
    if len(addrinfo) == 0:
        return None  # Give up trying
    addrs = set(addrinfo[i][-1][0] for i in range(len(addrinfo)))
    return addrs 


def freshDNS(domains: List[str]) -> None:
    '''
    Refresh the DNS lookup results in /etc/hosts
    '''
    global _HOSTS_

    if ag.verbose:
        print(_HOSTS_)

    if ag.reset or ag.refresh:
        with open(ag.hosts, 'w') as f:
            f.write(_HOSTS_)
        if ag.reset:
            raise SystemExit()

    print(f'\0337\x1b[1;36m# Found {len(domains)} domains.\x1b[m',
          file=sys.stderr)

    alladdrs = []  # List[Tuple(addr, domain)]
    if 0 == ag.workers:
        # Serial lookup
        for i, domain in enumerate(sorted(domains), 1):

            print(f'\033[K\0337\x1b[1;36m# Progress',
                  f' {i} / {len(domains)} ({i*100./len(domains):.1f}%)',
                  f'| \033[1;33m{domain}', end='\x1b[m\0338',
                  file=sys.stderr)
            sys.stderr.flush()

            addrs = getAddrs(domain)
            if addrs is None: continue

            for addr in addrs:
                alladdrs.append((addr, domain))
                if ag.verbose:
                    print(f'{addr}' + str(domain).rjust(79-len(addr)))

    else:
        # Parallel lookup
        Qin, Qout = mp.Queue(), mp.Queue()
        #Lin, Lout = mp.Lock(), mp.Lock()
        for domain in sorted(domains):
            Qin.put(domain)

        def worker_wrapper(qin: mp.Queue, qout: mp.Queue) -> None:
            try:
                while True:
                    if qin.empty(): return
                    domain = qin.get()
                    addrinfo = getAddrs(domain)
                    qout.put([addrinfo, domain])
            except KeyboardInterrupt as e:
                os._exit(1)

        # spawn workers
        workers = [mp.Process(target=worker_wrapper,
                   args=(Qin, Qout)) for _ in range(ag.workers)]
        for worker in workers: worker.start()

        outctr = len(alladdrs)
        spinner = Spinner()
        # wait for workers to get things done
        while True:
            if outctr == len(domains) or not any([w.is_alive() for w in workers]):
                print(f'\033[K\x1b[1;36m# Lookup finished.',
                      f'Pulling down the workers.', end='\x1b[m\n',
                      file=sys.stderr)
                for w in workers:
                    w.join(timeout=0.1)
                    w.terminate()
                break
            else:
                while Qout.qsize() > 0:
                    addrs, domain = Qout.get()
                    if addrs is None: continue

                    for addr in addrs:
                        alladdrs.append((addr, domain))
                        if ag.verbose:
                            print(f'{addr}' + str(domain).rjust(79-len(addr)))

                if outctr < len(alladdrs):
                    outctr = len(set([name for _, name in alladdrs]))
                    print(f'\033[K\0337\x1b[1;36m# Progress',
                          f' {outctr} / {len(domains)} ({outctr*100./len(domains):.1f}%)',
                          f'\033[1;33m', spinner.get(), end='\x1b[m\0338',
                          file=sys.stderr)
                    sys.stderr.flush()

            time.sleep(1e-3)


    # write the results to disk
    for addr, name in alladdrs:
        _HOSTS_ += f'{addr}' + str(name).rjust(79-len(addr)) + '\n'

    if ag.write or ag.refresh:
        with open(ag.hosts, 'w') as f:
            f.write(_HOSTS_)


if __name__ == '__main__':

    ag = argparse.ArgumentParser()
    ag.add_argument('-w', '--write', default=False,
                    action='store_true', help='write result to /etc/hosts')
    ag.add_argument('-i', '--reset', default=False,
                    action='store_true', help='reset /etc/hosts')
    ag.add_argument('-r', '--refresh', default=False,
                    action='store_true', help='refresh /etc/hosts')
    ag.add_argument('-v', '--verbose', default=False,
                    action='store_true', help='verbose')
    ag.add_argument('-H', '--hosts', type=str, default='/etc/hosts')
    ag.add_argument('-d', '--domains', type=str,
                    default=f'{os.getenv("HOME")}/.freshdnsrc')
    ag.add_argument('-f', '--firefox', default=False, action='store_true')
    ag.add_argument('-n', '--ns', default=False, action='store_true',
                    help='Change name servers in resolv.conf')
    ag.add_argument('--resolv', type=str, default='/etc/resolv.conf')
    ag.add_argument('-j', '--workers', type=int, default=0)
    # we don't explicitly pass ag to functions, but ag is used by them.
    ag = ag.parse_args()

    if ag.ns:
        # if -n is specified, setup resolv.conf and exit
        setResolvConf()

    else:
        # do straightforward dns cacheing
        domains = []

        # Read configuration file for domain list
        if os.path.exists(ag.domains):
            with open(ag.domains, 'r') as f:
                domains += [line.strip() for line in f.readlines()]

        # Get more domains from firefox history
        if ag.firefox:
            domains += getFirefoxPlaces()

        # FIXME: if ag.chromium:

        # de-dup and remove totally invalid ones
        domains = list(set(domains))
        domains = [x for x in domains if len(x) > 0]
        domains = [x for x in domains if '.' in x]

        try:
            freshDNS(domains)
        except KeyboardInterrupt:
            exit(1)
