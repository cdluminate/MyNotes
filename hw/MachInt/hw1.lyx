#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{times}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\ttfamily}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
HW#1
\end_layout

\begin_layout Author
Mo Zhou <mzhou32@jhu.edu>
\end_layout

\begin_layout Date
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Section
PEAS Description of Task Environment and Characterization
\end_layout

\begin_layout Itemize

\series bold
Playing-Soccer 
\series default
Partially observable, stochastic, sequential, dynamic, continuous, multi-agent.
\end_layout

\begin_layout Itemize

\series bold
Knitting-a-Sweater
\series default
 Fully observable, deterministic, sequential, static, continuous, single
 agent.
\end_layout

\begin_layout Itemize

\series bold
Bidding-on-an-item-at-an-Auction
\series default
 Partially observable, deterministic, sequential, static, discrete, single
 agent.
\end_layout

\begin_layout Section
To What Extent Are They AI Instances
\end_layout

\begin_layout Itemize

\series bold
Supermarket bar code scanners: 
\series default
Simple reflex agents.
 It does not need past states.
\end_layout

\begin_layout Itemize

\series bold
Web search engines: 
\series default
Agents with goals.
 Search engines maximizes the relevance between returned results and the
 user query.
\end_layout

\begin_layout Itemize

\series bold
Voice-activated telephone menus: 
\series default
Agents with memory.
 It has to memorize the owner's voice print.
\end_layout

\begin_layout Itemize

\series bold
Spelling and grammar correction features in word:
\series default
 Table-driven agents.
 Spelling and grammar can be dealt with simply tables.
\end_layout

\begin_layout Itemize

\series bold
Internet routing algorithms that respond dynamically: 
\series default
Agents with goals.
 It has to maximize the efficiency of the network routes and robustness.
\end_layout

\begin_layout Section
Can the following tasks be solved by computer?
\end_layout

\begin_layout Itemize
a.
 Playing a decent game of table tennis (Ping-Pong).
 
\begin_inset Newline newline
\end_inset

No.
 The current robots (actuators) cannot perform high-speed and accurate moves
 to play ping-pong.
 Meanwhile, it's still hard for the current AI systems (both in terms of
 hardware and software) to perform real-time computation for such sport.
 It will be a long time before the two problems can be addressed.
\end_layout

\begin_layout Itemize
b.
 Driving in the center of Cairo, Egypt.
 
\begin_inset Newline newline
\end_inset

No.
 There are complicated local conventions such as four short honks followed
 by a long one.
 However, it should be feasible with complicated engineering to incorporate
 these rules into the automobile system.
\begin_inset Newline newline
\end_inset

See https://www.news24.com/wheels/news/gear_and_tech/driverless-cars-might-follow-
the-rules-of-the-road-but-what-about-the-language-of-driving-20180119
\end_layout

\begin_layout Itemize
c.
 Driving in Victorville, California.
\begin_inset Newline newline
\end_inset

Yes.
 There are already experiments according to news report.
\begin_inset Newline newline
\end_inset

https://www.reuters.com/article/idUSIndia-30310720071104
\end_layout

\begin_layout Itemize
d.
 Buying a week’s worth of groceries at the market.
 
\begin_inset Newline newline
\end_inset

No.
 Navigation in the market is already difficult enough for the current state-of-t
he-art.
\end_layout

\begin_layout Itemize
e.
 Buying a week’s worth of groceries on the Web.
 
\begin_inset Newline newline
\end_inset

Yes.
 For example, Amazon Alexa is already able to shop online given instructions.
\end_layout

\begin_layout Itemize
f.
 Playing a decent game of bridge at a competitive level.
 
\begin_inset Newline newline
\end_inset

Yes.
 The environment is static, deterministic, sequential, discrete, and multi-agent.
 It is feasible to devise the logic to play this game.
\end_layout

\begin_layout Itemize
g.
 Discovering and proving new mathematical theorems.
 
\begin_inset Newline newline
\end_inset

Partly Yes.
 Proving theorems using AI is possible, see 
\begin_inset Quotes eld
\end_inset

Generative Language Modeling for Automated Theorem Proving
\begin_inset Quotes erd
\end_inset

, https://arxiv.org/abs/2009.03393
\begin_inset Newline newline
\end_inset

However discovering new theorem is still not feasible.
\end_layout

\begin_layout Itemize
h.
 Writing an intentionally funny story.
 
\begin_inset Newline newline
\end_inset

No.
 Although currently large language models like GPT can generate stories,
 the resulting stories are not necessarily fun or logically sensible.
\end_layout

\begin_layout Itemize
i.
 Giving competent legal advice in a specialized area of law.
 
\begin_inset Newline newline
\end_inset

No.
 The current AI systems can be used to assist human, but not to give competent
 advice.
\begin_inset Newline newline
\end_inset

https://emerj.com/ai-sector-overviews/ai-in-law-legal-practice-current-applicatio
ns/
\end_layout

\begin_layout Itemize
j.
 Translating spoken English into spoken Swedish in real time.
 
\begin_inset Newline newline
\end_inset

Yes.
 Youtube is already able to automatically add transcripts for videos and
 translate them in real-time as subtitle.
\end_layout

\begin_layout Itemize
k.
 Performing a complex surgical operation.
 
\begin_inset Newline newline
\end_inset

No.
 AI can only assist human, and cannot do it alone.
\end_layout

\begin_layout Section
missionaries and cannibals
\end_layout

\begin_layout Subsection
a
\end_layout

\begin_layout Standard
This is a search problem.
 The formulation is as follows:
\end_layout

\begin_layout Itemize
We define the state space using a pair of tokens, e.g.
 (MMMCCCB,) means the boat, three missionaries and three cannibals are on
 the same side of river as the initial state.
 The comma separates tokens on different sides of the river.
\end_layout

\begin_layout Itemize
The successor function is the boat.
 It ships one or two people across the river.
\end_layout

\begin_layout Itemize
The goal test is whether the search problem reached its ending state (,MMMCCCB)
\end_layout

\begin_layout Itemize
The solution of the search problem is to find the sequence (path) which
 transforms the initial state (MMMCCCB,) into the ending state (,MMMCCCB).
\end_layout

\begin_layout Standard
And there are some restrictions on the search problem:
\end_layout

\begin_layout Itemize
The boat cannot move itself over the river.
\end_layout

\begin_layout Itemize
The number of token 
\begin_inset Quotes eld
\end_inset

C
\begin_inset Quotes erd
\end_inset

 on each side cannot be larger than the number of token 
\begin_inset Quotes eld
\end_inset

M
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename drawing1.svg
	scale 30

\end_inset


\end_layout

\begin_layout Standard
The complete state space is shown in the diagram above.
\end_layout

\begin_layout Subsection
b
\end_layout

\begin_layout Standard
Actually by listing the whole state space using BFS, the solution is derived
 meanwhile, because there are always one valid choice for each step after
 removing the options that leads to invalid state or loops.
 So the solution is shown in the diagram above.
\end_layout

\begin_layout Standard
It is indeed a good idea to check for repeated states in order to avoid
 loops when searching for the path.
\end_layout

\begin_layout Subsection
c
\end_layout

\begin_layout Standard
Because people's intuition does not follow the clearly defined mathematical
 notations.
 Besides, there involves loops during the search process.
\end_layout

\begin_layout Section
True or False
\end_layout

\begin_layout Itemize
a.
 True.
 With an admissible heuristic, A* is optimal.
 In that case, DFS will always expands more nodes than A* does.
\end_layout

\begin_layout Itemize
b.
 True.
 
\begin_inset Formula $h(n)=0\leq h^{*}(n)$
\end_inset

, which satisfies the definition of admissible heuristics.
 In this case A* only relies on 
\begin_inset Formula $g(n)$
\end_inset

, namely the cumulative cost from the start to node 
\begin_inset Formula $n$
\end_inset

, and the algorithm degenerates into UCS.
\end_layout

\begin_layout Itemize
c.
 False.
 A* can be still useful when problems are appropriately transformed (or
 approximiated) into discrete form.
\end_layout

\begin_layout Itemize
d.
 True.
 BFS will not be trapped in loops like DFS does.
\end_layout

\begin_layout Itemize
e.
 True.
 Manhattan distance in this case is the shortest distance between square
 A and square B ignoring the obstacles.
 Hence, Manhattan distance is the lower bound of the true cost 
\begin_inset Formula $h^{*}(n)$
\end_inset

.
 Namely, we have 
\begin_inset Formula $h(n)\leq h^{*}(n)$
\end_inset

, which means Manhattan distance is admissible.
\end_layout

\begin_layout Section
Prove or Counterexample
\end_layout

\begin_layout Standard
1.
 True.
 BFS is a special case of UCS.
 Because when the costs for every node is the same, UCS degenerates into
 BFS.
 In this case, the cost contour exactly matches BFS's searching tier-by-tier
 order.
\end_layout

\begin_layout Standard
2.
 True.
 In the worst case, best-first (greedy) tree search degenerates into a badly-gui
ded DFS.
\end_layout

\begin_layout Standard
3.
 True.
 A* search considers forward (estinated) cost 
\begin_inset Formula $h(n)$
\end_inset

 and backward (cumulative) cost 
\begin_inset Formula $g(n)$
\end_inset

 simultaneously.
 A* degenerates into UCS when only 
\begin_inset Formula $g(n)$
\end_inset

 is considered by assigning weight 
\begin_inset Formula $w=0$
\end_inset

 to 
\begin_inset Formula $h(n)$
\end_inset

.
\end_layout

\begin_layout Section
Weighted A Star
\end_layout

\begin_layout Standard
Q1.
 For 
\begin_inset Formula $w\in[0,2]$
\end_inset

, this is complete.
\end_layout

\begin_layout Standard
Q2.
 Assumping 
\begin_inset Formula $h(\cdot)$
\end_inset

 is admissible, the function becomes optimal with 
\begin_inset Formula $w=1.$
\end_inset


\end_layout

\begin_layout Standard
Q3.
 When 
\begin_inset Formula $w=0$
\end_inset

, we have 
\begin_inset Formula $f(n)=2g(n)$
\end_inset

, which means the weighted A* degenerates into UCS.
 When 
\begin_inset Formula $w=1$
\end_inset

, we have 
\begin_inset Formula $f(n)=g(n)+h(n)$
\end_inset

, which means the weighted A* becomes the standard A*.
 When 
\begin_inset Formula $w=2$
\end_inset

, we have 
\begin_inset Formula $f(n)=h(n)$
\end_inset

, which means A* degenerates into greedy best-first search.
\end_layout

\begin_layout Section
Invent a Heuristic Function
\end_layout

\begin_layout Standard
Recall that an admissible heuristic 
\begin_inset Formula $h(n)$
\end_inset

 should be always 
\begin_inset Formula $\leq h^{*}(n)$
\end_inset

.
 Thus, a non-admissible heuristic 
\begin_inset Formula $h^{\#}(n)$
\end_inset

 that 
\begin_inset Quotes eld
\end_inset

sometimes overestimates
\begin_inset Quotes erd
\end_inset

 can be designed based on an admissible heuristic.
\end_layout

\begin_layout Section
Number of Combinations
\end_layout

\begin_layout Standard
The exact number of possible combinations is 
\begin_inset Formula $518,918,400$
\end_inset

, as calculated using a python program shown in Algorithm 1.
\end_layout

\begin_layout Standard
First, if we ignore the order of objects stacked at any position, we have
 
\begin_inset Formula $9^{8}$
\end_inset

 possible cases from 
\begin_inset Formula $(0,0,0,0,0,0,0,0)$
\end_inset

 to 
\begin_inset Formula $(8,8,8,8,8,8,8,8)$
\end_inset

, where each of the 8 numbers indicates the location 
\begin_inset Formula $(\in\{0,...,8\})$
\end_inset

 of the corresponding object.
 Hence, in Algorithm 1, we start from traversing through these cases using
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|it.product(...)|
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For each case, we have 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|locs|
\end_layout

\end_inset

 as the 
\begin_inset Formula $8$
\end_inset

-element location vector, based on which we can calculate possible cases
 of arrangements.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|Counter|
\end_layout

\end_inset

 class calculates the number of objects occurred in the same place, and
 the product of the factorials of the tallies will be the total possible
 cases based on the single branch of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|it.product(...)|
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Using PyPy3 (python with JIT), this program can give us the results within
 several seconds despite of the time complexity.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import math
\end_layout

\begin_layout Plain Layout

import operator as op
\end_layout

\begin_layout Plain Layout

import functools as ft
\end_layout

\begin_layout Plain Layout

import itertools as it
\end_layout

\begin_layout Plain Layout

import collections
\end_layout

\begin_layout Plain Layout

OBJS=8
\end_layout

\begin_layout Plain Layout

LOCS=9
\end_layout

\begin_layout Plain Layout

total=0
\end_layout

\begin_layout Plain Layout

for locs in it.product(range(LOCS), repeat=OBJS):
\end_layout

\begin_layout Plain Layout

    c = collections.Counter(locs)
\end_layout

\begin_layout Plain Layout

    total += ft.reduce(op.mul, (math.factorial(x) for x in c.values()))
\end_layout

\begin_layout Plain Layout

print(total)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Python Code for Question 9.
 Run with PyPy3 instead of cpython for speed up.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_body
\end_document
